# go中的锁

## 互斥锁
- sync.mutex
- 获取到互斥锁的任务，阻塞其他任务获取锁
- 意味着同一时间只能有1个任务，才能持有互斥锁

```go
package main

import (
	"log"
	"sync"
	"time"
)

// hcMuTex 它是一个互斥锁
var HcMutex sync.Mutex

func runMutex(id int)  {
	log.Printf("[任务id：%d][尝试获取锁]", id)
	HcMutex.Lock()
	log.Printf("[任务id：%d][get到了锁]", id)
	time.Sleep(5*time.Second)
	HcMutex.Unlock()
	log.Printf("[任务id：%d][干完了活，释放锁]", id)

}

func runHcLock()  {
	go runMutex(1)
	go runMutex(2)
	go runMutex(3)

}

func main(){
	runHcLock()
	time.Sleep(6*time.Minute)
}

/*
2021/08/05 09:10:05 [任务id：3][尝试获取锁]
2021/08/05 09:10:05 [任务id：3][get到了锁]
2021/08/05 09:10:05 [任务id：2][尝试获取锁]
2021/08/05 09:10:05 [任务id：1][尝试获取锁]

2021/08/05 09:10:10 [任务id：2][get到了锁]
2021/08/05 09:10:10 [任务id：3][干完了活，释放锁]

2021/08/05 09:10:15 [任务id：1][get到了锁]
2021/08/05 09:10:15 [任务id：2][干完了活，释放锁]

2021/08/05 09:10:20 [任务id：1][干完了活，释放锁]
*/
```

## 读写锁
- sync.RWmutex
1. 同时多个写锁任务，说明并非使用读写锁的写锁时，退化成了互斥锁
2. 同时多个读锁任务，说明使用读写锁的读锁，可以同时施加多把读锁
3. 先启动写锁任务，后并发5个读锁任务.当有写锁存在时，读锁是施加不了的。当写锁释放完，读锁可以施加多个
4. 先并发5个读锁任务，后启动1个写锁任务.当有读锁时，阻塞写锁

```go
package main

import (
	"log"
	"sync"
	"time"
)

// 读写锁
var rwMutex sync.RWMutex

func runReadLock(id int)  {
	log.Printf("[读任务 id：%d][进入读方法尝试获取锁]\n", id)
	rwMutex.RLock()
	log.Printf("[读任务 id：%d][get到读锁][开始干活，睡眠10秒]\n", id)
	time.Sleep(3*time.Second)
	rwMutex.RUnlock()
	log.Printf("[读任务 id：%d][完成任务，释放读锁]\n", id)
}

func runWriteLock(id int)  {
	log.Printf("[写任务 id：%d][进入写方法，尝试获取写锁]\n", id)
	rwMutex.Lock()
	log.Printf("[写任务 id：%d][get到写锁][开始干活，睡眠10秒]\n", id)
	time.Sleep(3*time.Second)
	rwMutex.Unlock()
	log.Printf("[写任务 id：%d][完成任务，释放写锁]\n", id)
}

// 全是写任务
func allWriteWorks(){
	for i:=1; i<3; i++{
	go runWriteLock(i)
}
}

// 全是读任务
func allReadWorks()  {
	for i:=1; i<3;i++{
		go runReadLock(i)
	}
}

// 先启动写任务
func writeFirst()  {
	go runWriteLock(1)
	time.Sleep(1 * time.Second)
	go runReadLock(1)
	go runReadLock(2)
	go runReadLock(3)

}

// 先启动读任务
func readFirst()  {
	go runReadLock(1)
	go runReadLock(2)
	go runReadLock(3)
	time.Sleep(1*time.Second)
	go runWriteLock(1)

}

func main(){

	log.Println("执行读写锁效果的函数")

	// 1. 同时多个写锁任务，说明如果并非使用读写锁的写锁时，退化成了互斥锁
	//allWriteWorks()

	// 2. 同时多个读锁任务，说明使用读写锁的读锁，可以同时施加多把读锁
	/*
		2021/08/06 06:37:30 执行读写锁效果的函数
		2021/08/06 06:37:30 [读任务 id：2][进入读方法尝试获取锁]
		2021/08/06 06:37:30 [读任务 id：2][get到读锁][开始干活，睡眠10秒]
		2021/08/06 06:37:30 [读任务 id：1][进入读方法尝试获取锁]
		2021/08/06 06:37:30 [读任务 id：1][get到读锁][开始干活，睡眠10秒]

		2021/08/06 06:37:33 [读任务 id：1][完成任务，释放读锁]
		2021/08/06 06:37:33 [读任务 id：2][完成任务，释放读锁]
	*/
	//allReadWorks()


	// 3. 先启动写锁任务，后并发5个读锁任务。当有写锁存在时，读锁时施加不了的。写锁释放完，读锁可以施加多个
	/*
	2021/08/06 06:39:33 执行读写锁效果的函数
	2021/08/06 06:39:33 [写任务 id：1][进入写方法，尝试获取写锁]
	2021/08/06 06:39:33 [写任务 id：1][get到写锁][开始干活，睡眠10秒]

	2021/08/06 06:39:34 [读任务 id：3][进入读方法尝试获取锁]
	2021/08/06 06:39:34 [读任务 id：1][进入读方法尝试获取锁]
	2021/08/06 06:39:34 [读任务 id：2][进入读方法尝试获取锁]

	2021/08/06 06:39:36 [读任务 id：3][get到读锁][开始干活，睡眠10秒]
	2021/08/06 06:39:36 [读任务 id：1][get到读锁][开始干活，睡眠10秒]
	2021/08/06 06:39:36 [读任务 id：2][get到读锁][开始干活，睡眠10秒]
	2021/08/06 06:39:36 [写任务 id：1][完成任务，释放写锁]
	2021/08/06 06:39:39 [读任务 id：3][完成任务，释放读锁]
	2021/08/06 06:39:39 [读任务 id：2][完成任务，释放读锁]
	2021/08/06 06:39:39 [读任务 id：1][完成任务，释放读锁]
	*/
	//writeFirst()


	// 4. 先并发5个读锁任务，后启动一个写锁任务，当有读锁时，阻塞写锁
	/*
	2021/08/06 06:41:14 执行读写锁效果的函数
	2021/08/06 06:41:14 [读任务 id：2][进入读方法尝试获取锁]
	2021/08/06 06:41:14 [读任务 id：2][get到读锁][开始干活，睡眠10秒]
	2021/08/06 06:41:14 [读任务 id：1][进入读方法尝试获取锁]
	2021/08/06 06:41:14 [读任务 id：1][get到读锁][开始干活，睡眠10秒]
	2021/08/06 06:41:14 [读任务 id：3][进入读方法尝试获取锁]
	2021/08/06 06:41:14 [读任务 id：3][get到读锁][开始干活，睡眠10秒]

	2021/08/06 06:41:15 [写任务 id：1][进入写方法，尝试获取写锁]

	2021/08/06 06:41:17 [读任务 id：1][完成任务，释放读锁]
	2021/08/06 06:41:17 [读任务 id：3][完成任务，释放读锁]
	2021/08/06 06:41:17 [读任务 id：2][完成任务，释放读锁]
	2021/08/06 06:41:17 [写任务 id：1][get到写锁][开始干活，睡眠10秒]
	
	2021/08/06 06:41:20 [写任务 id：1][完成任务，释放写锁]

	*/
	readFirst()

	time.Sleep(1 * time.Minute)
}
```